Automating Work at TACC Tutorial: Messaging Between Actors
==========================================================

Introduction
------------

While standalone Actors are useful, one can also network multiple Actors
to generate more complex workflows. Actors have the ability to send
messages to other Actors, allowing developers to chain together workflow
steps, each contained in a separate Actor.

In this section of the tutorial, we will deploy a simple
``upstream-messenger`` Actor that sends a message to the
``example-actor`` that we deployed in the previous section. We will
demonstrate that the downstream ``example-actor`` runs after it receives
the message from ``upstream-messenger``.

Create a New Actor Named ``upstream-messenger``
-----------------------------------------------

.. code:: bash

   tapis actors init --actor-name upstream-messenger
   cd upstream-messenger

Edit Actor Source
-----------------

The Actor we just created doesn’t do much, it just says “hello world,”
so let’s change its behavior so it does something more interesting, like
message another Actor. We will use the API command
`sendMessage <https://agavepy.readthedocs.io/en/master/docsite/actors/actors.html#sendmessage-send-a-message-to-an-actor-mailbox>`_
to implement this. Using your favorite text editor, edit the
``default.py`` script so it looks like:

.. code:: python

   from agavepy.actors import get_context, get_client


   def main():
       """Main entry to grab message context from user input"""
       context = get_context()
       m = context['raw_message']
       print("Actor received message: {}".format(m))

       # send message to downstream actor
       client = get_client()
       actorId = context['downstream_actor_id']
       message = 'hello, example-actor!'
       print("Sending message '{}' to {}".format(message, actorId))
       response = client.actors.sendMessage(actorId=actorId, body={"message": message})
       print("Successfully triggered execution '{}' on actor '{}'".format(response['executionId'], actorId))


   if __name__ == '__main__':
       main()

All we’ve done is add a block of code that calls the Tapis/Agave API so
that it sends a message to another Actor. This is, in essence, doing the
same thing as the CLI command ``tapis actors submit`` or
``tapis actors run``.

Notice that we haven’t actually defined **which** Actor ID we want to
send the message to. Per best practice, we’ve chosen not to “hard code”
the Actor ID into ``default.py``, but rather read it from the Actor
environment, which we access via ``context['downstream_actor_id']``. To
set the ``downstream_actor_id``, we need only define it in the Actor
context. Using your favorite text editor, make a new file
``secrets.json`` containing a ``downstream_actor_id``. The downstream
Actor is the ``example-actor`` we deployed previously, and we can
retrieve its ID using the CLI:

.. code:: bash

   $ tapis actors list
   +---------------+--------------------+-------+-------------------------------+--------------------------+--------+--------+
   | id            | name               | owner | image                         | lastUpdateTime           | status | cronOn |
   +---------------+--------------------+-------+-------------------------------+--------------------------+--------+--------+
   | MqqbarbazBB8x | example-actor      | eho   | tacc/hello-world:latest       | 2021-08-24T19:13:44.036Z | READY  | False  |
   +---------------+--------------------+-------+-------------------------------+--------------------------+--------+--------+

Then copy & paste that Actor ID into your ``secrets.json`` file:

.. code:: json

   {
       "downstream_actor_id": "MqqbarbazBB8x"
   }

Deploy Actor
------------

Our new ``upstream-messenger`` Actor is now ready to deploy using the
CLI:

.. code:: bash

   $ tapis actors deploy
   # ...
   | create | Created Tapis actor MDfoobar7AOwx                                                                 |
   | cache  | Cached actor identifier to disk 

   # ...and check successful deployment by waiting for Actor status to be READY
   $ tapis actors list
   +---------------+--------------------+-------+-------------------------------+--------------------------+--------+--------+
   | id            | name               | owner | image                         | lastUpdateTime           | status | cronOn |
   +---------------+--------------------+-------+-------------------------------+--------------------------+--------+--------+
   | MqqbarbazBB8x | example-actor      | eho   | tacc/hello-world:latest       | 2021-08-24T19:13:44.036Z | READY  | False  |
   | MDfoobar7AOwx | upstream-messenger | eho   | enho/upstream-messenger:0.0.1 | 2021-08-24T20:23:07.619Z | READY  | False  |
   +---------------+--------------------+-------+-------------------------------+--------------------------+--------+--------+

Send Message to ``upstream-messenger`` Using CLI
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once the ``upsteam_messenger`` Actor is READY, we can trigger a new
execution by sending it a message:

.. code:: bash

   $ tapis actors run -m 'hello, upstream-messenger!' MDfoobar7AOwx
   Actor received message: hello, upstream-messenger!
   Sending message 'hello, example-actor!' to MqqbarbazBB8x
   Successfully triggered execution '5P7foobarrrA6' on actor 'MqqbarbazBB8x'

Check Execution of Downstream ``example-actor``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The goal of this tutorial was to send a message to
``upstream-messenger`` and have it trigger an execution on
``example-actor``. Let’s check the logs of this execution:

.. code:: bash

   $ tapis actors execs logs MqqbarbazBB8x 5P7foobarrrA6 
   Logs for execution 5P7foobarrrA6 
    Actor received message: hello, example-actor!

Conclusion
~~~~~~~~~~

Congratulations! We have successfully deployed a workflow that sends a
message between two Actors. Of course, real-world multi-Actor workflows
will send much more useful information than “hello, world.” In practice,
messages contain file paths, names of analyses to run, and other
metadata. It is also possible for one Actor to send messages to multiple
other Actors, allowing for a single action such as a file upload to
trigger many downstream processes, such as file management, running
analyses, logging, and more.

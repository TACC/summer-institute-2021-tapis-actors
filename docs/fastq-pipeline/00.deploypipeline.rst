Deploying a Sequencing Pipeline
=============================

Introduction
------------

Thus far, we have demonstrated several useful features of actors:

* Deployment, execution, and handling using Tapis CLI
* Logging to 3rd party services (Slack in our example)
* Inter-Actor messaging

In this section of the tutorial, we will demonstrate this toolbox in a realistic example: a basic pipeline for
validating DNA sequencing data.

.. image:: ../images/20210916_taccster_actors_pipeline.png
   :width: 600
   :alt: A basic data pipeline for running FastQC

We will leverage a few additional Actor capabilities beyond what we have covered previously:

* Actors can access TACC's Stockyard (AKA ``/work``) filesystem
* Actors can submit HPC jobs, by submitting to Tapis Applications

Reusing as much of our previous work as possible, pipeline deployment will consist of the following steps:

* Change ``upstream-messenger`` so it downloads a fastq data file from the web to TACC Stockyard filesystem
* Re-deploy ``upstream-messenger`` so it sends the path to data file to the ``fastqc-launcher``
* Deploy new actor ``fastqc-launcher``
* Deploy a Tapis App ``eho-fastqc-0.11.9`` that runs the `FastQC tool <https://github.com/sequana/fastqc>`_ as HPC job

Since deploying Tapis Apps is outside the scope of this tutorial, I have already completed the final step. 
If you are interested in learning how to deploy Tapis Applications, I encourage you to consult
one of our `in-depth Tapis tutorials <https://tacc-cloud.github.io/summer-institute-2021-tapis/>`_ .

Edit ``upstream-messenger`` Source
----------------------------------

Using your favorite text editor, edit the ``default.py`` for ``upstream-messener`` so it looks like:

.. code:: python

   import os
   from agavepy.actors import get_context, get_client
   import requests


   def download_fastq(out_path) -> None:
      """Download a demo fastq file from the web to path `out_path`."""
      url = 'https://raw.githubusercontent.com/eho-tacc/fastqc_app/main/tests/data_R1_001.fastq'
      fq_file = requests.get(url, allow_redirects=True)
      with open(out_path, 'wb') as f:
         f.write(fq_file.content)


   def main():
      """Main entrypoint"""
      context = get_context()
      m = context['raw_message']
      print("Actor received message: {}".format(m))

      # Get an active Tapis client
      client = get_client()

      # Pull in the downstream Actor ID from the environment
      downstream_actor_id = context['DOWNSTREAM_ACTOR_ID']
      # alternatively:
      # downstream_actor_id = os.environ['DOWNSTREAM_ACTOR_ID']

      # Download our fastq file to TACC Stockyard
      out_path = '/work/06634/eho/my_reads.fastq'
      download_fastq(out_path)

      # Using our Tapis client, send the message containing file path 
      # to the downstream Actor
      message = out_path
      print("Sending message '{}' to {}".format(message, downstream_actor_id))
      response = client.actors.sendMessage(actorId=downstream_actor_id, body={"message": message})
      print("Successfully triggered execution '{}' on actor '{}'".format(response['executionId'], downstream_actor_id))


   if __name__ == '__main__':
       main()


Deploy Another Actor ``fastqc-launcher``
----------------------------------------

We also want to create the downstream Actor: one that launches an submits an HPC job to a 
Tapis App. Recall that Tapis apps are wrappers around computationally intensive processes. They are similar
to Actors in that they can be managed using the Tapis API, but unlike Actors, they are HPC jobs under the
hood.

.. image:: ../images/20210916_taccster_actors_pipeline.png
   :width: 600
   :alt: A basic data pipeline for running FastQC


Similar to the ``upstream-messenger``, this new Actor (which we will call ``fastqc-launcher``) leverages the active Tapis client 
to interact with the Tapis ecosystem. In this case, we will submit to a 
Tapis Application instead of messaging another Actor. We instantiate a new 
Actor as before:

.. code:: bash

   tapis actors init --template default --actor-name fastqc-launcher
   cd fastqc_launcher
   echo '{}' > secrets.json

We also edit the Actor source code in ``default.py`` so it resembles:

.. code:: python

   import os
   from agavepy.actors import get_context, get_client


   def main():
      context = get_context()
      fastq_path = context['raw_message']
      print("Actor received message: {}".format(fastq_path))

      # Validate the fastq file. Here, we merely check that the path looks
      # like a valid Agave/Tapis URI
      assert fastq_path.startswith('agave://')

      # Get an active Tapis client
      client = get_client()

      # Using our Tapis client, submit a job to Tapis App eho-fastqc-0.11.9
      body = {
         "name": "fastqc-test",
         "appId": "eho-fastqc-0.11.9",
         "archive": false,
         "inputs": {
            "fastq": fastq_path
         }
      }
      response = client.jobs.submit(body=body)
      print("Successfully submitted job {} to Tapis App {}".format(response['id'], response['appId']))


   if __name__ == '__main__':
       main()


Re-deploy Actor ``upstream-messenger``
--------------------------------------

Our Actor ``upstream-messenger`` is still configured to send messages to ``hello-world-actor``. 
We would instead like it to send messages to our new actor ``fastqc-launcher``, so we must
re-deploy it with a new ``DOWNSTREAM_ACTOR_ID``:

.. code:: bash

   # TODO
   $ tapis actors create --repo taccuser/upstream-messenger:0.0.1 \
                         -n upstream-messenger \
                         -d "Sends message to another actor" \
                         -e DOWNSTREAM_ACTOR_ID=MqqbarbazBB8x
   +----------------+-----------------------------------+
   | Field          | Value                             |
   +----------------+-----------------------------------+
   | id             | MDfoobar7AOwx                     |
   | name           | upstream-messenger                |
   | owner          | taccuser                          |
   | image          | taccuser/upstream-messenger:0.0.1 |
   | lastUpdateTime | 2021-08-26T20:33:20.320620        |
   | status         | SUBMITTED                         |
   | cronOn         | False                             |
   +----------------+-----------------------------------+


Send Message to ``upstream-messenger`` Using CLI
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once the ``upsteam_messenger`` Actor is READY, we can trigger a new
execution by sending it a message:

.. code:: bash

   $ tapis actors submit -m 'hello, upstream-messenger!' MDfoobar7AOwx
   +-------------+----------------------------+
   | Field       | Value                      |
   +-------------+----------------------------+
   | executionId | MDanexec7AOwx              |
   | msg         | hello, upstream-messenger! |
   +-------------+----------------------------+

As usual, we check the status of the execution, and show the logs when
it finishes:

.. code:: bash

   $ tapis actors execs show MDfoobar7AOwx MDanexec7AOwx
   +-----------+-----------------------------+
   | Field     | Value                       |
   +-----------+-----------------------------+
   | actorId   | MDfoobar7AOwx               |
   | apiServer | https://api.tacc.utexas.edu |
   | id        | MDanexec7AOwx               |
   | status    | COMPLETE                    |
   | workerId  | wZvworker1KmQ               |
   +-----------+-----------------------------+
   $ tapis actors execs logs MDfoobar7AOwx MDanexec7AOwx
   Actor received message: hello, upstream-messenger!
   Sending message 'greetings, hello-world-actor!' to MqqbarbazBB8x
   Successfully triggered execution '5P7foobarrrA6' on actor 'MqqbarbazBB8x'

Check Execution of Downstream ``hello-world-actor``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The goal of this tutorial was to send a message to
``upstream-messenger`` and have it trigger an execution on
``hello-world-actor``. Let’s check the status of the execution and inspect
the logs:

.. code:: bash

   $ tapis actors execs show MqqbarbazBB8x 5P7foobarrrA6 
   +-----------+-----------------------------+
   | Field     | Value                       |
   +-----------+-----------------------------+
   | actorId   | MqqbarbazBB8x               |
   | apiServer | https://api.tacc.utexas.edu |
   | id        | 5P7foobarrrA6               |
   | status    | COMPLETE                    |
   | workerId  | DJPworkerzKlN               |
   +-----------+-----------------------------+
   $ tapis actors execs logs MqqbarbazBB8x 5P7foobarrrA6 
   Logs for execution 5P7foobarrrA6 
    Actor received message: hello, hello-world-actor!

Conclusion
~~~~~~~~~~

Congratulations! We have successfully deployed a workflow that sends a
message between two Actors. Of course, real-world multi-Actor workflows
will send much more useful information than “hello, world.” In practice,
messages contain file paths, names of analyses to run, and other
metadata. It is also possible for one Actor to send messages to multiple
other Actors, allowing for a single action such as a file upload to
trigger many downstream processes, such as file management, running
analyses, logging, and more.
